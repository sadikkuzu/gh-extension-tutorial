# User Input

In this chapter we'll add support for handling user input. User input can come in many forms:

- flags (like `gh lol roulette --repo foo/bar`)
- arguments (like `gh lol roulette "prs"`)
- prompts (like the flow in `gh repo create`
- STDIN (like when you pipe one command to another as in `ls foo/ | wc -l`)

We'll be focusing on the first three as the fourth is more advanced.

## Flags

We already have our persistent flag, `--repo`, which is respected in both of our subcommands. `roulette` don't need any additional flags, but we want to accept `-l/--loud` in `yell`.

Below the definition of `yellCmd`, add:

```go
// yellCmd := &cmd.Command{...

yellCmd.Flags().IntP("loud", "l", 0, "how loud to be")
```

then add a new function at the top level of `main.go`:

```go
func runYell(cmd *cobra.Command, repo repository.Repository) (err error) {
  loud, _ := cmd.Flags().GetInt("loud")

  if loud < 1 {
    return fmt.Errorf("expected a loudness of at least 1, got '%d'", loud)
  }

  return
}
```

Next, actually call the new `runYell` function by updating `yellCmd`:

```go
// ... other commands defined above ...
yellCmd := &cobra.Command{
  Use:   "yell",
  Short: "Print a list of issues loudly",
  RunE: func(cmd *cobra.Command, args []string) (err error) {
    return runYell(cmd, repo)
  },
}
```

We'll circle back and actually make use of the `loud` parameter later, but right now let's jump over to `gh lol roulette` and support an argument.

## Arguments

Meanwhile, over in `gh lol roulette`, we accept 0 or 1 positional arguments instead of a flag.

First, add a new function to the top of `main.go`:

```go
func runRoulette(cmd *cobra.Command, repo repository.Repository, args []string) (err error) {
	if len(args) > 0 {
		fmt.Printf("gonna mess with %s\n", args[0])
	}
  return
}
```

Then update the definition of `rouletteCmd` to account for its argument and for its new function:

```go
rouletteCmd := &cobra.Command{
  Use:   "roulette [<type>]",
  Short: "Close a random thing in a repository.",
  Args:  cobra.MaximumNArgs(1),
  RunE: func(cmd *cobra.Command, args []string) (err error) {
    return runRoulette(cmd, repo, args)
  },
}
```

## Interactivity

If `yell` is run with no explicit `--loud` flag or if `roulette` is run without a type argument, I want to prompt the user for input. I like this approach and use it in `gh` itself for two reasons:

- it encourages scripts to be explicit in what options they are using
- it acts as a guide for new users (avoids running, getting an error, scouring help)


Before editing any code, run:

```bash
go get github.com/AlecAivazis/survey/v2
```

to obtain the library we're going to use for interactivity.

Now delete what was in `runRoulette` and replace it with:

```go
func runRoulette(cmd *cobra.Command, repo repository.Repository, args []string) (err error) {
  var resourceType string
  resourceTypes := []string{
    "prs",
    "issues",
  }
  if len(args) > 0 {
    resourceType = args[0]
    valid := false
    for _, t := range resourceTypes {
      if t == resourceType {
        valid = true
      }
    }
    if !valid {
      return fmt.Errorf("invalid type of resource '%s'; expected one of %v", resourceType, resourceTypes)
    }
  } else {
    var choice int
    if err = survey.AskOne(&survey.Select{
      Message: "Close what kind of thing?",
      Options: resourceTypes,
    }, &choice); err != nil {
      return
    }
    resourceType = resourceTypes[choice]
  }

  return
}
```

_ !!! _ Your editor is probably adding to the import list at the top for you. If you are getting compilation errors, however, manually add `"github.com/AlecAivazis/survey/v2` to the import list at the top of `main.go`.

Next, update `runYell`:

```go
func runYell(cmd *cobra.Command, repo repository.Repository) (err error) {
  var func runYell(cmd *cobra.Command, repo repository.Repository) (err error)
  loudFlag := cmd.Flags().Lookup("loud")
  if !loudFlag.Changed {
    if err = survey.AskOne(&survey.Input{
      Message: "How loud?",
      Default: "1",
    }, &loud); err != nil {
      return
    }
  } else {
    loud, _ = cmd.Flags().GetInt("loud")
  }

  if loud < 1 {
    return fmt.Errorf("expected a loudness of at least 1, got '%d'", loud)
  }

  return
}
```

## Recap

Our two subcommands can now take input from a variety of sources and in a variety of ways. In the next chapter we'll actually do something with our inputs.
